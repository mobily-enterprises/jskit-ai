X Add client-server shared code
X User screen and user configuration
X Major tidying up, avoid repeated code, best way to write tests 
X Harmonise/understand schema
X Gravatar, + Profile picture upload and S3 integration/filesystem?
X Finish login/user management properly

X Config/multihoming: App configuration, loaded at boot time AND Multihoming, app configuration becomes workspace configuration
X Load user settings on app load IF that is best practice and doesn't happen already
X More permissions (multihoming)
X Add a backend interface, explain how to make it work, what code to share

X Check functionality of the multiple surfaces/workspaces
X Make sure each screen is short
X Major reorganise of files
X Get full test coverage
X Final check to the code, still from a distance
X IMPORTANT: Diminish boilerplate as much as possible for new CRUDs
X Decide what to do for "server health" app, which stands outside of it all. Maybe new surface point?
X Log server errors and client errors
- Final check: app usability and bugs
- Add final rails, practices, post checks

- Add email system (SMTP?, Amazon?)
- Add SMS system (PLIVIO?)
- Add websocket infrastructure with realtime updates
- AI integration (actions abstraction etc.)
- CI policy gate: fail build when any `workspaceSurface: "admin"` route lacks `permission` (explicit allowlist for exceptions)
- One (or more) of the "extra" stuff in the admin interface
- FINAL CODE CHECK, write onboarding document, go through it carefully

Extra:
- Operational hygiene (structured logging, tracing, health checks, alerts)
- Security controls (rate limits, audit trails, rotation, dependency scans, pentests)
- Data handling (validation, encryption, retention/purge policies, backups)
- Testing & automation (CI, regression/e2e coverage, performance benchmarks)
- Observability (business metrics, uptime, capacity signals)
