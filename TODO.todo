X Add client-server shared code
X User screen and user configuration
X Major tidying up, avoid repeated code, best way to write tests 
X Harmonise/understand schema
X Gravatar, + Profile picture upload and S3 integration/filesystem?
X Finish login/user management properly

X Config/multihoming: App configuration, loaded at boot time AND Multihoming, app configuration becomes workspace configuration
X Load user settings on app load IF that is best practice and doesn't happen already
X More permissions (multihoming)
X Add a backend interface, explain how to make it work, what code to share

X Check functionality of the multiple surfaces/workspaces
X Make sure each screen is short
X Major reorganise of files
X Get full test coverage
X Final check to the code, still from a distance
X IMPORTANT: Diminish boilerplate as much as possible for new CRUDs
X Decide what to do for "server health" app, which stands outside of it all. Maybe new surface point?
X Log server errors and client errors
X Add email system (SMTP?, Amazon?)
X Add SMS system (PLIVIO?)
X Add websocket infrastructure with realtime updates

- AI integration (actions abstraction etc.)

- Payments

- User chats


- Check why pending invites don't appear
- Create an "alerts" system so that users can see their alerts

- Final check: app usability and bugs, improvements

- Is this done? CI policy gate: fail build when any `workspaceSurface: "admin"` route lacks `permission` (explicit allowlist for exceptions)
- FINAL CODE CHECK, write onboarding document, go through it carefully
- Add final rails, practices, post checks


LATER:

- Make db-agnostic (now MySql)
- DB-level audit trail [1]
- SMS/EMAIL
  - Medium: invite-email failures are fully swallowed, so delivery/config issues are invisible in ops. (server/domain/workspace/services/admin.service.js:315)
  - Medium: SMS send permission is coupled to invite permission (workspace.members.invite), which is workable now but not ideal least-privilege for future comms features. (server/modules/communications/routes.js:12)
  - Low: SMS text is trim()'d before send, which mutates payload content (can matter for OTP formatting/messages with intentional whitespace). (server/domain/communications/services/sms.service.js:27)
  - Low: SMTP from currently requires a normalized bare email; common Display Name <email@...> formats would be treated as unconfigured. (server/domain/workspace/services/inviteEmail.service.js:42)


  Appendices:

  [1]

    Two variants:

  1. Fully transparent to app code

  - Use MySQL triggers (AFTER INSERT/UPDATE/DELETE) on target tables.
  - Triggers write old/new row JSON into an audit table.
  - You get DB-level truth, but “who” is only DB account (CURRENT_USER()), not
    app user.

  2. Mostly transparent, with real app user identity

  - Keep the same triggers.
  - Add one central Knex wrapper that sets session vars per request/transaction
    (@audit_user_id, @audit_request_id, etc.).
  - Triggers read those vars when writing audit rows.
  - App changes are minimal if all writes already go through shared transaction
    helpers.

  So: yes, largely transparent, but if you need exact end-user attribution,
  there must be at least a small central app hook to pass request context into
  DB session variables.
